## Question 3

**Each individual partner's questions 1 and 2 must be completed before starting this problem.**

Ordinarily, each Logo procedure accepts a certain fixed number of arguments.
There are two exceptions to this rule. First, some primitive procedures (but
only primitives) can accept variable numbers of arguments, just as in Scheme.
In Logo, such a procedure has a "default" number of arguments -- this is the
number that logo-eval will ordinarily look for. If you want to use a different
number of arguments, you must enclose the entire expression in parentheses as
you would in Scheme:

`? print sum 2 3 `

`5`

`? print sum 2 3 4 ; this is an error`

`5`

`You don't say what to do with 4`

`? print (sum 2 3 4)`

`9`

`?`

Second, certain primitive procedures need access to the current environment in
order to do their job. For example, MAKE, which is Logo's equivalent to SET!,
takes two arguments, a variable name and a new value, but the procedure that
implements it requires a third argument, the current environment, since the
job is done by modifying that environment. In the Scheme metacircular
evaluator, this problem is less noticeable because SET! is a special form
anyway -- its first argument isn't evaluated -- and so it is handled directly
by eval itself. In Logo we have no special forms except for TO, so MAKE is an
ordinary procedure handled by logo-apply, but we still need to indicate that
it needs the environment as an extra "hidden" argument.

In this interpreter a procedure is represented as a four-element list:

`(name type-flag arg-count text)`

NAME is the procedure's name. (Unlike Scheme's first-class procedures which
can be created by lambda without a name, every Logo procedure must have a name
in order to exist at all.)

TYPE-FLAG is a symbol, either PRIMITIVE or COMPOUND. The former means that the
procedure is written in Scheme (or is a Scheme primitive); the latter means
that the procedure was defined in Logo, using TO.

ARG-COUNT is the number of arguments that the procedure expects. For most
procedures, this is a straightforward nonnegative integer. In this part of the
project, we are going to deal with the exceptions discussed above. For a
procedure that accepts variable numbers of arguments, ARG-COUNT will be a
negative integer, the negative of the default number of arguments. For a
procedure that requires the environment as an extra argument, ARG-COUNT will
be a list whose only element is the number of visible arguments, before the
environment is added. (No procedure is in both categories.) Examples:

`(list 'type 'primitive 1 logo-type) ;ordinary case`

`(list 'word 'primitive -2 word) ;variable # of args`

`(list 'make 'primitive '(2) make) ;2 visible args plus env`

These lists are generated by the add-prim procedure that you can see in logo-
meta.scm along with entries for all the existing primitives.

TEXT is either a Scheme procedure, for a primitive, or a list whose first
element is a list of formal parameters and whose remaining elements are
instruction lines making up the body of the procedure, for a user-defined Logo
procedure.

The actual collection of argument values, corresponding to list-of-values in
the metacircular evaluator, is called collect-n-args in the Logo interpreter.
It has an extra argument, n, which is the number of arguments to be collected
from the line-object. If that argument is negative, then collect-n-args will
keep evaluating argument expressions until it sees a right parenthesis.
(Remember that we allow a variable number of arguments only if the expression
is in parentheses.)

Your job is to modify the invocation of collect-n-args to handle both of the
special cases described here. If the arg-count in the procedure is a list,
call collect-n-args with its car as the number, and cons the current
environment onto the front of the resulting argument list. If the arg-count is
negative, you should use its absolute value as the number unless this
invocation is inside parentheses. (There is a local variable paren-flag that
will be #T in this situation, #F otherwise.)

Once you've done this, modify the primitive table entries for sum, product,
word, sentence, and list so that they can accept variable numbers of
arguments.

Then test your work:

`? ifelse equalp 2 3 [print "yes] [print "no]`

`? ifelse equalp 3 3 [print "yes] [print "no]`

`? print ifelse equalp 2 3 [product 5 6] [product 8 9]`

`? print (sum 4 5 6 7 8)`

`? print (word "a "b "c)`

`? print (sum 4 5 product 6 7 8)`

## Question 4

We are going to invent variables. Most of the work has already been done,
because the environment structure is exactly like that of the Scheme
metacircular evaluator. There are two things left for you to handle: First,
eval-prefix uses data abstraction procedures VARIABLE? and VARIABLE-NAME to
detect and process a variable reference. In Scheme, any symbol is a variable
reference, since procedure names are variables too. In Logo, a variable
reference is a symbol whose first character is a colon (:) and the actual
variable name is all but the first character of that symbol. Write the
necessary procedures.

Second, Scheme provides two different special forms, DEFINE and SET!, for
creating a new variable binding and for changing an existing binding. In Logo
there is one procedure, MAKE, that serves both purposes. If there is already a
binding for the given name in the current environment, then MAKE acts like
SET!. If not, then MAKE creates a new binding in the global environment.
(Note, this is not necessarily the current frame.) Make the MAKE procedure in
logo.scm call the right logo-meta.scm procedures to accomplish this, modifying
those procedures if necessary.

Test your work:

`? make "foo 27`

`? print :foo`

`27`

`?`

(Why the quotation mark? Remember, MAKE isn't a special form. The VALUE OF its
first actual argument expression has to be the name we want to bind.)

Note: You can't fully test this yet, because you won't know if it does the
right thing for local variables until we can define and invoke procedures. For
now, just test that it works for global variables.

**Now each individual partner should do their respective number 5.**

##  Question 6

**Both question 5's for person A and B must be done before you start this problem!**

Evaluating procedure bodies. In the metacircular evaluator, APPLY sets up an
environment and uses eval-sequence to evaluate each expression in the
procedure body. The Logo interpreter does the same, except that the job of
eval-sequence is different. Its argument is a list of instruction lists. Each
of those lists must be turned into a line-object before it can be evaluated.
Also, we must take into account the fact that instructions are different from
expressions; the instruction lines in the procedure body should generally
return =NO-VALUE= when evaluated. If not, eval-sequence must signal the error
"You don't say what to do with" the value.

The exceptions are the two primitive commands that can end a procedure
invocation early, STOP (for commands) and OUTPUT (for operations). If STOP is
invoked, it will return the symbol =STOP=; if OUTPUT is invoked, it will
return a pair whose car is =OUTPUT= and whose cdr is the desired return value:

`(add-prim 'stop 0 (lambda () '=stop=))`

`(add-prim 'output 1 (lambda (x) (cons '=output= x)))`

If eval-sequence evaluates a STOP, it should immediately return =NO-VALUE=. If
it gets an OUTPUT, it should immediately return the value provided (the cdr of
that pair).

##  Question 7

Dynamic scope. In the metacircular evaluator, MC-APPLY handles compound (user-
defined) procedures by setting up an environment and evaluating the procedure
body (using eval-sequence) in that environment. LOGO-APPLY must do the same
thing, but instead of Scheme's lexical scope, in which the new environment
extends the one in which the procedure was created, it must follow Logo's
dynamic scope, in which the new environment extends the current environment.

The version of LOGO-APPLY we give you doesn't handle compound procedure calls.
Modify it as needed, along with any other changes required to go along with
this one. (Hint: Start by looking at the MC-APPLY version.)

Once you've solved these problems, you should be able to define and invoke
procedures:

`? make "x 3`

`? to scope :x`

`> helper 5`

`> end`

`? to helper :y`

`> print (sentence :x :y)`

`> end`

`? scope 4`

**Now each individual partner should do their respective question 8.

## Question 9

**Question 8 for both partners must be done before you attempt this problem!**

Static variables. This is a feature that isn't in normal versions of Logo, but
our version will be extra powerful! As we've discussed in class, one of the
problems with dynamic scope is that you can't create local state variables by
defining a procedure inside the scope of a variable the way we do in Scheme.
We are going to invent a mechanism by which a procedure definition can specify
the names and initial values of local state variables.

Here is an example showing the notation:

`? to count :increase static :counter 2+3`

`-> make "counter :counter + :increase`

`-> print :counter`

`-> end`

  
`? count 20`

`25`

`? count 1`

`26`

`? print :counter`

`ERROR -- UNBOUND VARIABLE COUNTER`

In the first line of the procedure definition, STATIC is a keyword that
indicates the end of the formal parameters and the beginning of alternating
names and values of local state variables. In the example shown here, there is
only one local state variable, named COUNTER, with an initial value of 5.
(Notice that the name is not evaluated, but the initial value expression is
evaluated, in the global environment.)

When the procedure is defined, it is given a local state variable named
COUNTER whose value is 5. Each time the procedure is called, it changes the
value of that variable. As the example shows, the name COUNTER is not defined
in the global environment.

To make this work, you must give every compound procedure a private frame
containing its static variables. This frame will be a fifth element of the
list that represents a procedure. When a compound procedure is invoked, you
will still extend the current (dynamic) environment, but you'll extend it with
two frames: the remembered static-variable frame, and the standard newly-
created frame in which formal parameters are bound to actual arguments.

Most of your work will be done in two places: the place where TO lines are
parsed, and the place where procedures are invoked.

The interpreter is now complete. Congratulations!

---------------------------------------------------------------------------------------------------- 

Optional for hotshots: Handle infix precedence properly.

(Of course there's a lot more that could be done, especially about error
handling, but also including missing primitives. Logo enthusiasts might like
to try to invent LOCAL, CATCH, THROW, DEFINE, TEXT, etc.)

## submitting

Be sure to indicate at the top of each file you turn in who is partner A and
who is partner B!

To submit, run `submit proj4` from your project 4 directory. Submit `logo.scm,
logo-meta.scm`, and any transcripts you have made. Be sure to enter your
partner's login!

